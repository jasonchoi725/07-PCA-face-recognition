1. 이미지 파일을 불러옴
2. n개의 이미지 파일을 읽음. 한 개의 이미지 파일은 50*50이라고 가정
3. n개의 이미지 파일을 2차원 넘파이 배열로 만듦.
4. n개의 이미지 파일을 각각 1차원?...2차원?... 2500*1의 길쭉한 넘파이 배열로 바꿈.
5. 이렇게 만든 n개의 2500*1의 넘파이 배열을 좌측에서 오른쪽으로 쫙 붙여줌.
6. 이렇게 붙이면, 한 row는 모든 이미지의 같은 위치의 픽셀의 픽셀값임.
7. 그러면 한 row의 평균값을 구하면, 그 위치의 픽셀값의 평균값임.
8. 이렇게 평균값을 모든 2500개의 픽셀 위치에 대해서 구함.
9. 이 평균값을 2500*1의 배열로 만들어줌. (자연스럽게 이렇게 나오겠지)
9-1. 이 평균값 배열을 이미지로 다시 재구성하면, 모든 얼굴들의 평균 얼굴이 나올거임. 모든 얼굴들이 섞여있는 얼굴.
10. 이 평균값의 배열을 n개의 2500*1의 넘파이 배열에서 모든 열에서 빼줌.
10-1. 이렇게 빼주는 이유는, 굳이 서로 겹치는 부분에 대해서 분석해줄 필요가 없으니까. 컴퓨팅 파워만 낭비하는거니까.
11. 이렇게 평균값을 빼준 배열에서 공분산 행렬을 구해야함.
11-1. 공분산을 구하는 방법은 공분산 행렬=AA^t임.
11-2. 그런데 이렇게 구하면 데이터가 개커짐.
11-3. 그래서 A^tA로 구함.
12. 이렇게 해서 구한 공분산 행렬에서 eigenvector를 구해야함.
12-1. 이 과정도 직접 알고리즘을 짜서 하고 싶었지만, 매우 매우 복잡하고 어려운 함수가 필요하다는 것을 알게됨. (수업에서는 그냥 넘어감)
13. 구한 eigenvector를 다 사용하는 것이 아니라, 몇 개만 쓸거임.
13-1. 왜냐하면 다 사용하지 않아도 대부분의 데이터 내용을 반영할 수 있기 때문임.
14. eigenvector를 내림차순해서 위에서 몇 개의 eigenvector만 선택.
14-1. 몇 개를 선택할지도 구하는 방식이 있는데, 알아봐야함.
15. 사용할 eigenvector에 다시 평균을 뺀 배열을 곱하면 원래 배열의 eigenvector를 구할 수 있음.
16. 그 다음 그거를 사용해서 변환행렬?을 구해야함. 알아봐야함.
